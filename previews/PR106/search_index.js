var documenterSearchIndex = {"docs":
[{"location":"generated/HowTo/group_average/#Calculate-group-averages","page":"Calculate group average","title":"Calculate group averages","text":"using UnfoldBIDS, PyMNE\nusing Unfold\nusing DataFrames\nusing Statistics\nusing CairoMakie, AlgebraOfGraphics\nusing LazyArtifacts","category":"section"},{"location":"generated/HowTo/group_average/#Analysis","page":"Calculate group average","title":"Analysis","text":"First let's redo the steps from the quickstart tutorial\n\nsample_data_path = UnfoldBIDS.erp_core_example();\nlayout_df = bids_layout(sample_data_path, derivatives=false);\ndata_df = load_bids_eeg_data(layout_df);\nnothing #hide\n\nCalculate results\n\nbasisfunction = firbasis(Ï„=(-0.2,.8),sfreq=1024)\nf  = @formula 0~1\nbfDict = [\"stimulus\"=>(f,basisfunction)]\nUnfoldBIDS.rename_to_latency(data_df, :sample); # Unfold expects a :latency collumn in your events; if your event latency is named differently you can use this function as remedy\n\nresultsAll = run_unfold(data_df, bfDict; eventcolumn=\"trial_type\");\nnothing #hide\n\nNow, let's transform the data into a tidier format (Note: We use raw data without a high-pass filter here so estimates will be quite off)\n\ntidy_df = unpack_results(bids_coeftable(resultsAll))\nfirst(tidy_df, 5)","category":"section"},{"location":"generated/HowTo/group_average/#Calculate-average-over-subjects","page":"Calculate group average","title":"Calculate average over subjects","text":"mean_df = combine(groupby(tidy_df, [:time, :coefname]), :estimate => mean)\nfirst(mean_df, 5)\n\nImportantly, the above can be extended to groupbyan arbitrary number of covariates!","category":"section"},{"location":"generated/HowTo/group_average/#Plot-results-using-AOG","page":"Calculate group average","title":"Plot results using AOG","text":"plt = data(mean_df) * mapping(:time, :estimate_mean, color = :coefname, group=:coefname => nonnumeric) * visual(Lines)\ndraw(plt, axis=(yticklabelsvisible=false,))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/#UnfoldBIDS._load_results","page":"API: Toolbox Functions","title":"UnfoldBIDS._load_results","text":"_load_results(files_df; generate_Xs::Bool = true)\n\nInternal function to load Unfold models into memory. Can also be used to load data after file information was loaded lazily (lazy=true) using load_results()\n\n\n\n\n\n","category":"function"},{"location":"api/#UnfoldBIDS.add_event_files!-Tuple{Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.add_event_files!","text":"add_event_files!(layoutDF)\n\nFunction to find and load all events file-paths into Layout-DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.bids_coeftable-Tuple{Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.bids_coeftable","text":"bids_coeftable(model_df)\n\nTurns all models found in model_df into tydy DataFrames and aggregates them in a new DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.bids_effects-Tuple{DataFrames.DataFrame, Dict}","page":"API: Toolbox Functions","title":"UnfoldBIDS.bids_effects","text":"bids_effects(model_df::DataFrame, effects_dict::Dict)\n\nCalculate mariginalized effect on all subjects found in the model dataframe using effects_dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.bids_layout-Tuple{AbstractString}","page":"API: Toolbox Functions","title":"UnfoldBIDS.bids_layout","text":"bids_layout(bidsPath::AbstractString;\n    derivatives::Bool=true,\n    specific_folder::Union{Nothing,AbstractString}=nothing,\n    exclude_folder::Union{Nothing,AbstractString}=nothing,\n    ses::Union{Nothing,AbstractString}=nothing,\n    task::Union{Nothing,AbstractString}=nothing,\n    run::Union{Nothing,AbstractString}=nothing)\n\nMain function to load paths of all subjects in one bids_root folder. Will return a DataFrame containing all found paths with specific subject information. Used before loading data into memore using load_bids_eeg_data\n\nKeywords\n\nderivatives::Bool = true\n Look for data in the derivatives folder\nspecific_folder::Union{Nothing,AbstractString} = nothing\n Specify a specific folder name in either derivatives or bids_root to look for data.\nexclude_folder::Union{Nothing,AbstractString} = nothing\n Exclude a specific folder from data detection.\nses:Union{Nothing,AbstractString} = nothing\n Which session to load; loads all if nothing\ntask::Union{Nothing,AbstractString} = nothing\n Which task to load; loads all if nothing\nrun::Union{Nothing,AbstractString} = nothing\n Which run to load; loads all if nothing\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.check_df-NTuple{4, Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.check_df","text":"check_df(files_df, ses, task, run)\n\nInternal; Checks if the multiple sessions/task/runs are found if none of these are provided\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.extract_subject_id!-Tuple{Any, Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.extract_subject_id!","text":"extract_subject_id!(files_df, file)\n\nInternal function to get subject information from dataframe.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.list_all_paths-Tuple{Any, Any, Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.list_all_paths","text":"list_all_paths(path)\n\nInternal function to find pathfiles\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.load_bids_eeg_data-Tuple{Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.load_bids_eeg_data","text":"load_bids_eeg_data(layout_df; verbose::Bool=true, kwargs...)\n\nLoad data found with bids_layout into memory.\n\nloading_function::Union{Nothing,Function} = nothing \n Function to load EEG data; if nothing provided and PyMNE.jl is loaded, it will use that as default. The function must take a single argument: the file path to the EEG data file.    \nverbose::Bool = true\n Show ProgressBar\nkwargs...\n kwargs for CSV.read to load events from .tsv file; e.g. to specify delimeter\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.load_events-Tuple{DataFrames.DataFrame}","page":"API: Toolbox Functions","title":"UnfoldBIDS.load_events","text":"load_events(layoutDF::DataFrame; kwargs...)\n\nInternal function to load events based on paths in the layout Df\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.load_results-Tuple{String}","page":"API: Toolbox Functions","title":"UnfoldBIDS.load_results","text":"load_results(bids_root::String;\n    derivatives_subfolder::String=\"Unfold\",\n    lazy::Bool=false,\n    generate_Xs::Bool = true,\n    ses::Union{Nothing,AbstractString}=nothing,\n    task::Union{Nothing,AbstractString}=nothing,\n    run::Union{Nothing,AbstractString}=nothing)\n\nLoad Unfold models existing in a derivatives_subfolder in your BIDS root folder. \n\nKeywords\n\nderivatives_subfolder::String = \"Unfold\"\n Defines in which subfolder of bids_root/derivatives to look for Unfold models.\nlazy::Bool = false\n Do not actually load the dataset into memore if true, only return a dataframe with paths\ngenerate_Xs::Bool = true\n By default recreate the designmatrix; Can be set to false, to improve loading time.\nses::Union{Nothing,AbstractString} = nothing\n Which session to load; loads all if nothing\ntask::Union{Nothing,AbstractString} = nothing\n Which task to load; loads all if nothing\nrun::Union{Nothing,AbstractString} = nothing\n Which run to load; loads all if nothing\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.rename_to_latency-Tuple{Any, Symbol}","page":"API: Toolbox Functions","title":"UnfoldBIDS.rename_to_latency","text":"rename_to_latency(data_df)\n\nThis is a convenience function to add a :latency collumn (needed by Unfold) based on another variable in the events_df (e.g. sample)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.run_unfold-Tuple{DataFrames.DataFrame, Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.run_unfold","text":"run_unfold(data_df, bf_vec; \n\tremove_time_expanded_Xs=true, \n\textract_data = raw_to_data, \n\tverbose::Bool=true, \n\tkwargs...)\n\nRun Unfold analysis on all data in data_df. Needs to have PyMNE.jl loaded!\n\nArguments\n\ndata_df::DataFrame\n DataFrame containing BIDS data as returned by load_bids_data(). Must contain collumns: :subject, :ses, :task, :run, :raw, :events\nbf_vec\n Basis function vector as expected by Unfold.jl's fit() function.\n\n\nCan be one of: \\\n- `[\"eventname\" => (formula, basisfunction)]` for overlap corrected models\n- `[\"eventname\" => (formula, timewindow)]` for mass-univariate models, where indicates (start, stop) in seconds with `typeof(timewindow) = Tuple{Real, Real}`\n\nKeywords\n\nremove_time_expanded_Xs::Bool = true\n Removes the timeexpanded designmatrix which significantly reduces the memory-consumption. This Xs is rarely needed, but can be recovered (look into the Unfold.load function)\nextract_data::function = nothing\n Specify the function to extract the data to a data array. Falls back to raw_to_data which uses get_data and allows to pick channels if no function is povided AND PyMNE is loaded - see @Ref(raw_to_data).\nverbose::Bool = true)\n Show ProgressBar or not.\nkwargs...\n Will be passed to both the fit() and  extract_data() calls as function inputs.\n For possible kwargs to fit() please have a look at the Unfold.jl API: https://unfoldtoolbox.github.io/UnfoldDocs/Unfold.jl/stable/references/functions/\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.save_results-Tuple{DataFrames.DataFrame, String}","page":"API: Toolbox Functions","title":"UnfoldBIDS.save_results","text":"save_results(results::DataFrame, bids_root::String; \n    derivatives_subfolder::String=\"Unfold\",\n    overwrite::Bool=false)\n\nFunction to save unfold models in your BIDS root folder. Automatically creates a derivatives_subfolder (default = \"Unfold\") in the derivatives and subsequentely safes each model in results according to BIDS. Example of path to saved file: bids_root/derivatives/Unfold/sub-XXX/eeg/sub-XXX_ses-XX_task-XXX_run-XX_unfold.jld2\n\nKeywords\n\nderivatives_subfolder::String = \"Unfold\"\n Creates the named subfolder and saves Unfold models according to BIDS.\noverwrite::Bool = false\n Does not overwrite existing datasets; can be set to true.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.unpack_events-Tuple{DataFrames.DataFrame}","page":"API: Toolbox Functions","title":"UnfoldBIDS.unpack_events","text":"unpack_events(df::DataFrame)\n\nUnpack events into tidy data frame; useful with AlgebraOfGraphics.jl\n\ndf is expected to be a UnfoldBIDS DataFrame where events are loaded already.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldBIDS.unpack_results-Tuple{Any}","page":"API: Toolbox Functions","title":"UnfoldBIDS.unpack_results","text":"unpack_results(results_df)\n\nUnpack all results into one tidy dataframe/ coeftable.\n\n\n\n\n\n","category":"method"},{"location":"generated/reference/BIDS/#Brain-Imaging-Data-Structure","page":"Brain Imaging Data Structure","title":"Brain Imaging Data Structure","text":"If you are using UnfoldBIDS we assume you are already familiar with the BIDS format. However, since the package only works if your dataset is BIDS formatted, here is a quick reminder. If you want a more in-depth explanation, please refer to the official BIDS documentation","category":"section"},{"location":"generated/reference/BIDS/#Folder-Structure","page":"Brain Imaging Data Structure","title":"Folder Structure","text":"Folders have to follow the following structure:\n\n  |-BIDS-Root/\n      |--- [required meta files]\n      |--- sub-<label>/\n          |--- eeg/\n              |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_eeg.<extension>\n              |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_eeg.json\n              |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_events.json\n              |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_events.tsv\n      |--- derivatives/ <- for (pre-processed data)\n         |--- [required meta files]\n         |--- sub-<label>/\n              |--- eeg/\n                  |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_eeg.<extension>\n                  |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_eeg.json\n                  |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_events.json\n                  |--- sub-<label>[_ses-<label>]_task-<label>[_acq-<label>][_run-<index>]_events.tsv","category":"section"},{"location":"generated/reference/BIDS/#File-formats","page":"Brain Imaging Data Structure","title":"File formats","text":"By BIDS standard your files have to be in one of the following formats: EEG\n\nedf (European Data Fromat; single file)\nvhdr (BrainVision format; file triplet of .vhdr, .vmrk and .eeg)\nset (EEGLAB saved file; .fdt file optional)\nfif (MNE save file; not BIDS conform, but implemented for convenience)\n\nEvents UnfoldBIDS.jl will automatically try to load accompanying events.tsv files. Loading events from the EEG data files is currently not supported, and not BIDS conform.","category":"section"},{"location":"generated/reference/BIDS/#BIDS-Transformation","page":"Brain Imaging Data Structure","title":"BIDS Transformation","text":"If your dataset is not yet BIDS conform you can use MNE-BIDS to transform your data.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/reference/overview/#Toolbox-overview","page":"Toolbox overview","title":"Toolbox overview","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"using UnfoldBIDS, PyMNE # PyMNE is needed because loading is now an extension\nusing Unfold\nusing LazyArtifacts","category":"section"},{"location":"generated/tutorials/quickstart/#Loading-data","page":"Quickstart","title":"Loading data","text":"To load use UnfoldBIDS to find the paths to all subject specific data you can uye the bidsLayout function:\n\nsample_data_path = UnfoldBIDS.erp_core_example()\nlayout_df = bids_layout(sample_data_path, derivatives = false)\n\nThis will give you a DataFrame containing the paths too the eeg files of all subjects plus their accompanying event files\n\nnote: Note\nSince we set the derivative keyword to false here UnfoldBIDS will only look for the raw EEG files. However, by default UnfoldBIDS assumes you have preprocessed data in a derivatives folder and try to look for those.\n\nSubsequently, you can load the data of all subjects into memory\n\ndata_df = load_bids_eeg_data(layout_df)\n\nnote: Note\nAt this point in time, the data is not yet actually loaded into memory, but uses MNE's lazy loading functionality.\n\nAs you can see, UnfoldBIDS trys to load events directly into the DataFrame, however if you are missing the event tsv files you will get a warning and no events are loaded. If that happens you have to manually load these events. The following function might help you with this. (The resulting dataframe still needs to be added to data_df!)\n\nevents_df = load_events(layout_df)","category":"section"},{"location":"generated/tutorials/quickstart/#Run-unfold-type-models","page":"Quickstart","title":"Run unfold type models","text":"basisfunction = firbasis(Ï„ = (-0.2, 0.8), sfreq = 1024)\nbasisfunction_resp = firbasis(Ï„ = (-0.4, 0.4), sfreq = 1024)\nf = @formula 0 ~ 1\nbfDict = [\"stimulus\" => (f, basisfunction), \"response\" => (f, basisfunction_resp)]\nUnfoldBIDS.rename_to_latency(data_df, :sample) # Unfold expects a :latency collumn in your events; if your event latency is named differently you can use this function as remedy\n\nresultsAll = run_unfold(data_df, bfDict; eventcolumn = \"trial_type\");\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/HowTo/ApplyPreprocessing/#Apply-MNE-preprocessing","page":"Apply preprocessing functions","title":"Apply MNE preprocessing","text":"When using run_unfold on your BIDS dataset it is usually assumed that your data is already preprocessed (or you want to have a look at the raw data). However, you also have the option to apply some further processing to your data. This is done by providing a custom function as extract_data keyword to run_unfold.\n\nI.e. run_unfold(dataDF, bfDict; extract_data = your_custom_function)\n\nBy default raw_to_data is used, if PyMNE is loaded.\n\nfunction raw_to_data(raw; channels::AbstractVector{<:Union{String,Integer}}=[])\n  return pyconvert(Array, raw.get_data(picks=pylist(channels), units=\"uV\"))\nend\n\nYou can exchange this function through an arbitrary function (applying MNE processing as needed), as long as it takes the raw MNE data object and returns a pyconverted Julia Array containing the data stream. For example\n\nusing PyMNE\n\nfunction raw_to_filtered_data(raw; channels::AbstractVector{<:Union{String,Integer}}=[], l_freq=0.5, h_freq=45)\n\n  # Load data into memory\n  loaded = raw.copy.load_data() # Make a copy to not modify original raw\n\n  # Re-reference to mastoids and add Cz back in\n  PyMNE.add_reference_channels(loaded, ref_channels=pylist([\"Cz\"]), copy=false)\n  loaded.set_eeg_reference(ref_channels=pylist([\"RM\", \"LM\"]))\n\n  # Filter data\n  loaded.filter(l_freq, h_freq, picks=\"eeg\")\n\n  return pyconvert(Array, loaded.get_data(picks=pylist(channels), units=\"uV\"))\nend\n\nHowever, including a preprocessing step right before fitting your model can often be a bottleneck in performance. If you think you will more likely only apply some preprocessing and then play around with the model, it's often more advisable to preprocess the raw objects in the dataframe before fitting.\n\nfunction ref_and_filter_data!(raw; l_freq=0.5, h_freq=45)\n  raw.load_data()\n\n  # Re-reference to mastoids and add Cz back in\n  UnfoldBIDS.PyMNE.add_reference_channels(raw, ref_channels=UnfoldBIDS.pylist([\"Cz\"]), copy=false)\n  raw.set_eeg_reference(ref_channels=UnfoldBIDS.pylist([\"RM\", \"LM\"]))\n\n  # Filter data\n  raw.filter(l_freq, h_freq, picks=\"eeg\")\n\nend\n\nfor row in eachrow(loaded_data_df)\n  ref_and_filter_data!(row.raw)\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/HowTo/IO/#Save/-load-Unfold.jl-results","page":"Save/ load Unfold results","title":"Save/ load Unfold.jl results","text":"With UnfoldBIDS you can easily save your unfold results in a BIDS conform way, and later load those results. Under the hood, this is a more fancy application of the way you can save results with Unfold.jl","category":"section"},{"location":"generated/HowTo/IO/#Save","page":"Save/ load Unfold results","title":"Save","text":"To save results you only need your results DataFrame, which was returned by run_unfold(), and the path to your BIDS root folder\n\nsave_results(results, bids_root)\n\nUnfoldBIDS will then automatically create a dedicated \"Unfold\" folder in your derivatives and save each subject's UnfoldModel in a BIDS conform way in JLD2 format. The data will then be saved as path/to/your/bids_root/derivatives/Unfold/sub-XXX/eeg/sub-XXX_ses-XX_task-XXX_run-XX_unfold.jld2\n\nnote: Note\nsave_results has two more keywords: derivatives_subfolder let's you specifiy a different foldername than \"Unfold\"; and overwrite::Bool indicates if the function should check for existing files with the same name.","category":"section"},{"location":"generated/HowTo/IO/#Load","page":"Save/ load Unfold results","title":"Load","text":"To load results that have been saved with save_results(), simply provide your bids_root folder again + any further information necessary (for example which run to load, or if you have saved the results in folder different than the \"Unfold\" default)\n\nload_results(bids_root)\n\nYou can additionally specifiy to load results, lazily (using the keyword lazy=true) to only load the paths/filenames; or choose to not reconstruct the designmatrix (using the keyword generate_Xs=false)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#UnfoldBIDS.jl-Documentation","page":"Home","title":"UnfoldBIDS.jl Documentation","text":"Welcome to the documentation for UnfoldBIDS, a helpful wrapper for Unfold style analysis applied to BIDS structured datasets.\n\nIf you need more information on BIDS, a quick overview and further reading can be found at Reference/Brain Imaging Data Structure\n\n(Image: Flowchart showing UnfoldBIDS' place in the Unfold environment)\n\n<div style=\"width:60%; margin: auto;\">\n</div>","category":"section"},{"location":"#Key-features-and-usage","page":"Home","title":"Key features & usage","text":"Find paths to all subject data within a BIDS dataset with one function ðŸ”Ž\nApply MNE-preprocessing directly before the fit âš’ï¸\nApply Unfold.jl style analysis on all subjects in one go âš¡\nMade using DataFrames.jl, ready for second level analysis ðŸ","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"julia> using Pkg; Pkg.add(\"UnfoldBIDS\")\n\nFor more detailed instructions please refer to Installing Julia & Unfold Packages.","category":"section"},{"location":"#Where-to-start:-Learning-roadmap","page":"Home","title":"Where to start: Learning roadmap","text":"","category":"section"},{"location":"#1.-First-steps","page":"Home","title":"1. First steps","text":"ðŸ”— Quickstart","category":"section"},{"location":"#2.-Intermediate-topics","page":"Home","title":"2. Intermediate topics","text":"ðŸ“Œ Goal: Use DataFrames to calculate group averages\n\nðŸ”— Calculate group average","category":"section"},{"location":"#3.-Advanced-topics","page":"Home","title":"3. Advanced topics","text":"ðŸ“Œ Goal: Data preprocessing using MNE\n\nðŸ”— Apply preprocessing functions","category":"section"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"UnfoldBIDS.jl integrates the loading of BIDS-compliant datasets with the Unfold.jl package into a single, cohesive tool, enabling streamlined rERP analysis of BIDS-compliant data. This simplifies the otherwise cumbersome and error-prone task of writing scripts to load subject data iteratively, reducing it to just a few lines of code.\n\nFor researchers not relying on a subject list to look up subject-specific data, the default approach recursively walks through the entire directory, adding file paths that match a specific pattern. However, this method can be slow, particularly in directories with numerous subfolders, as required by BIDS. UnfoldBIDS.jl addresses this issue by using the Continuables.jl package to quickly search for suitable file paths, speeding up file searches even in large datasets with hundreds of subjects.\n\nAdditionally, many researchers write their loading scripts using loops that load data directly and recursively into memory, which can slow down the process, especially with large datasets. UnfoldBIDS.jl overcomes this in two ways. First by forcing the user to initially load and inspect all paths, including subject specific data, to make sure only datasets are loaded that are actually needed. And second, by utilizing MNE's lazy loading function by default, ensuring that data is only loaded when necessary. In summary, UnfoldBIDS.jl provides a convenient interface for processing BIDS-compliant EEG data in the Julia programming language.\n\n<!---\nNote: The statement of need is also used in the `README.md`. Make sure that they are synchronized.\n-->","category":"section"},{"location":"generated/HowTo/find_non_bids/#How-to-find-non-BIDS-and/or-non-EEG-data","page":"Find non-BIDS conform data","title":"How to find non-BIDS and/or non-EEG data","text":"In some cases you might want to use a dataset that is not (entirely) BIDS compatible. While UnfoldBIDS.jl is expecting you to comply with the BIDS structure, you can also make use of the underlying functions to (at least) find your data.\n\nThe key element here is that a lot of what bids_layout() is doing, is to find the right data based on your input. However, you can also do that manually, by using UnfoldBIDS.list_all_paths() The function takes in a few keywords:\n\nUnfoldBIDS.list_all_paths(path, file_ending, file_pattern; exclude=nothing)\n\nWhere\n\npath::String = path_to_data_folder; should be input with abspath() \n\nfile_ending::String = data_file_ending; UnfoldBIDS is looking for file_ending = [\".set\", \".fif\", \".vhdr\", \".edf\"], but maybe you are looking for a \".mat\" or \".nifti\"? \n\nfile_pattern::String = ses_task_run; this control for which session/task/run you are looking for (e.g. \"ses-001\"); can be empty String to look for everything: file_pattern = [\"\"] \n\nexclude = folder_to_exclude; If there is a folder in your pathtodata_folder you want to exclude you can input this here; defaults to nothing\n\n\nIn an applied case you would then:\n\n# path settings\nbidsPath = \"path/to/folder\"\nfile_ending = [\".mat\"]\nfile_pattern = [\"\"]\nexclude = nothing\n\n# Find paths\nall_paths = collect(UnfoldBIDS.list_all_paths(abspath(bidsPath), file_ending, file_pattern, exclude=exclude))\n\nnote: Note\nIt is not tested whether you can find data that is stored in a different way than BIDS structured (e.g. all files in one folder instead of one sub-XXX folder per subject); but technically this should be possible.\n\nAdditionally you want to put your found paths in a nicer DataFrame containing subject specific information\n\n# Init a files DataFrame\nfiles_df = DataFrame(subject=[], ses=[], task=[], run=[], file=[])  # Initialize an empty DataFrame to hold results\n\n# Add subject information\nfor path in all_paths\n    UnfoldBIDS.extract_subject_id!(files_df, path)\nend\n\n# Check for multiple session/tasks/runs\nses = nothing; task = nothing; run = nothing;\nUnfoldBIDS.check_df(files_df, ses, task, run)\n\nnote: Note\nThis does not look for your events; and if you used a different file ending than UnfoldBIDS' default you won't be able to use load_bids_eeg_data with your DataFrame!\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
